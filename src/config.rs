use std::{
    borrow::Cow,
    fs::{self, File},
    io::Write,
    path::PathBuf,
};

use foximg_color::FoximgColor;
use raylib::prelude::*;
use serde::{Deserialize, Serialize};

use crate::Foximg;

mod foximg_color;
#[cfg(target_os = "windows")]
mod win32;

#[inline(always)]
fn get_config_path_current_exe(file: &'static str) -> anyhow::Result<PathBuf> {
    let mut path = std::env::current_exe()?;
    path.pop();

    #[cfg(not(target_os = "windows"))]
    let file = format!(".{file}");
    path.push(file);

    Ok(path)
}

fn get_config_path(
    file: &'static str,
    local: bool,
    rl: Option<&mut RaylibHandle>,
) -> anyhow::Result<PathBuf> {
    if !cfg!(target_os = "windows") && !cfg!(debug_assertions) {
        let mut path: PathBuf = match std::env::var(if local {
            "XDG_STATE_HOME"
        } else {
            "XDG_CONFIG_HOME"
        }) {
            Ok(config) => config.into(),
            Err(_) => {
                let Result::<PathBuf, _>::Ok(mut path) =
                    std::env::var("HOME").map(|path| path.into())
                else {
                    if let Some(rl) = rl {
                        rl.trace_log(
                            TraceLogLevel::LOG_WARNING, 
                            &format!("FOXIMG: \"HOME\" enviroment variable not set. Searching executable's directory for \"{file}\"'"
                        ));
                    }
                    return self::get_config_path_current_exe(file);
                };

                if local {
                    path.push(".local");
                    if !path.exists() {
                        fs::create_dir(&path)?;
                    }

                    path.push("state");
                    if !path.exists() {
                        fs::create_dir(&path)?;
                    }
                } else {
                    path.push(".config");
                    if !path.exists() {
                        fs::create_dir(&path)?;
                    }
                }

                path
            }
        };

        path.push("foximg");
        if !path.exists() {
            fs::create_dir(&path)?;
        }

        path.push(file);
        Ok(path)
    } else {
        self::get_config_path_current_exe(file)
    }
}

fn config_try_new<C>(rl: &mut RaylibHandle) -> anyhow::Result<C>
where
    C: FoximgConfig,
{
    let file = fs::read_to_string(self::get_config_path(C::FILE, C::LOCAL, Some(rl))?)?;

    let settings: C = toml::from_str(&file)?;
    Ok(settings)
}

fn config_try_to_file<C>(config: &C) -> anyhow::Result<()>
where
    C: FoximgConfig,
{
    let settings = toml::to_string(config)?;
    let mut file = File::create(self::get_config_path(C::FILE, C::LOCAL, None)?)?;

    write!(&mut file, "# This file was auto-generated by foximg. ")?;
    if C::LOCAL {
        writeln!(&mut file, "\n")?;
    } else {
        writeln!(
            &mut file,
            "As of {} modifying the config files is unstable.",
            env!("CARGO_PKG_VERSION")
        )?;
        writeln!(
            &mut file,
            "# Future versions of foximg will add functionality to modify the config files"
        )?;
        writeln!(
            &mut file,
            "# through the app. Be careful messing with this file as an incorrect config"
        )?;
        writeln!(
            &mut file,
            "# will delete itself and create a default one again!\n"
        )?;
    }
    write!(&mut file, "{settings}")?;
    Ok(())
}

pub trait FoximgConfig
where
    Self: Default + Serialize + for<'de> Deserialize<'de>,
{
    /// Represents the filename in which the config will be saved in. This is merely the name of the
    /// config and not the full path. The path is figured out during run-time. It's possible the actual
    /// filename could start with `.` in some cases.
    const FILE: &'static str;

    /// Represents whether the config file reflects the local state of foximg.
    const LOCAL: bool;

    /// Updates the config. This gets called in `new`.
    fn update(&self, rl: &mut RaylibHandle);

    fn new(rl: &mut RaylibHandle) -> Self {
        rl.trace_log(
            TraceLogLevel::LOG_INFO,
            &format!("FOXIMG: Loading \"{}\"", Self::FILE),
        );

        let settings = match self::config_try_new(rl) {
            Ok(settings) => settings,
            Err(e) => {
                rl.trace_log(
                    TraceLogLevel::LOG_WARNING,
                    &format!("FOXIMG: Couldn't deserialize \"{}\":", Self::FILE),
                );

                // TOML parsing errors tend to be multiple lines long. We split them into mutliple
                // messages so that they can fit and be neatly formatted.
                for el in e.to_string().lines() {
                    rl.trace_log(TraceLogLevel::LOG_WARNING, &format!("    > {el}"));
                }

                let settings = Self::default();
                rl.trace_log(
                    TraceLogLevel::LOG_INFO,
                    &format!("FOXIMG: Creating new \"{}\"", Self::FILE),
                );

                settings.to_file(rl);
                settings
            }
        };

        settings.update(rl);
        settings
    }

    fn to_file(&self, rl: &RaylibHandle) -> bool {
        if let Err(e) = config_try_to_file(self) {
            rl.trace_log(
                TraceLogLevel::LOG_WARNING,
                &format!("FOXIMG: Couldn't write to \"{}\":", Self::FILE),
            );
            rl.trace_log(TraceLogLevel::LOG_WARNING, &format!("    > {e}"));
            false
        } else {
            true
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct FoximgState {
    pub w: i32,
    pub h: i32,
    pub xy: Option<(i32, i32)>,

    pub maximized: bool,
    pub fullscreen: bool,
}

impl Default for FoximgState {
    fn default() -> Self {
        Self {
            w: 640,
            h: 480,
            xy: None,
            maximized: false,
            fullscreen: false,
        }
    }
}

impl FoximgState {
    fn log_state(&self, rl: &RaylibHandle) {
        macro_rules! log_field {
            ($rl:ident, $self:ident.$field:ident) => {
                $rl.trace_log(
                    TraceLogLevel::LOG_INFO,
                    &format!(concat!("    > ", stringify!($field), ": {}"), $self.$field),
                )
            };
        }

        log_field!(rl, self.w);
        log_field!(rl, self.h);

        if let Some((x, y)) = self.xy {
            rl.trace_log(TraceLogLevel::LOG_INFO, &format!("    > x: {x}"));
            rl.trace_log(TraceLogLevel::LOG_INFO, &format!("    > y: {y}"));
        }

        log_field!(rl, self.maximized);
        log_field!(rl, self.fullscreen);
    }

    fn set_state(&self, rl: &mut RaylibHandle) {
        rl.set_window_size(self.w, self.h);
        if let Some((x, y)) = self.xy {
            rl.set_window_position(x, y);
        }
        if self.maximized {
            rl.maximize_window();
        }
        if self.fullscreen {
            rl.toggle_borderless_windowed();
        }
    }
}

impl FoximgConfig for FoximgState {
    const FILE: &str = "foximg_state.toml";
    const LOCAL: bool = true;

    fn update(&self, rl: &mut RaylibHandle) {
        self.log_state(rl);
        self.set_state(rl);
    }
}

#[derive(Serialize, Deserialize)]
pub struct FoximgSettings {
    pub antialiasing: bool,
}

impl Default for FoximgSettings {
    fn default() -> Self {
        Self {
            antialiasing: false,
        }
    }
}

impl FoximgConfig for FoximgSettings {
    const FILE: &str = "foximg_settings.toml";
    const LOCAL: bool = false;

    fn update(&self, _: &mut RaylibHandle) {}
}

#[derive(Serialize, Deserialize)]
pub struct FoximgStyleOptionals {
    pub name: Option<Cow<'static, str>>,
    pub author: Option<Cow<'static, str>>,

    pub bg_disabled: Option<FoximgColor>,
    pub bg_focused: Option<FoximgColor>,
    pub border: Option<FoximgColor>,
    pub border_disabled: Option<FoximgColor>,
    pub border_focused: Option<FoximgColor>,
    pub text: Option<FoximgColor>,
    pub text_disabled: Option<FoximgColor>,
    pub text_focused: Option<FoximgColor>,
}

impl Default for FoximgStyleOptionals {
    fn default() -> Self {
        const DEFAULT_NAME: &str = "Default Dark";
        const DEFAULT_AUTHOR: &str = "bruvy";

        Self {
            name: Some(Cow::Borrowed(DEFAULT_NAME)),
            author: Some(Cow::Borrowed(DEFAULT_AUTHOR)),
            bg_disabled: Default::default(),
            bg_focused: Default::default(),
            border: Default::default(),
            border_disabled: Default::default(),
            border_focused: Default::default(),
            text: Default::default(),
            text_disabled: Default::default(),
            text_focused: Default::default(),
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct FoximgStyle {
    #[serde(flatten)]
    pub optionals: FoximgStyleOptionals,
    pub dark: bool,
    pub accent: FoximgColor,
    pub bg: FoximgColor,
}

impl FoximgStyle {
    fn log_style(&self, rl: &mut RaylibHandle) {
        macro_rules! log_field {
            ($rl:ident, $self:ident.$field:ident) => {
                $rl.trace_log(
                    TraceLogLevel::LOG_INFO,
                    &format!(concat!("    > ", stringify!($field), ": {}"), $self.$field),
                )
            };
            ($rl:ident, $self:ident.optionals.$field:ident) => {
                if let Some(ref $field) = $self.optionals.$field {
                    $rl.trace_log(
                        TraceLogLevel::LOG_INFO,
                        &format!(concat!("    > ", stringify!($field), ": {}"), $field),
                    )
                }
            };
        }

        log_field!(rl, self.optionals.name);
        log_field!(rl, self.optionals.author);
        log_field!(rl, self.dark);
        log_field!(rl, self.accent);
        log_field!(rl, self.bg);
        log_field!(rl, self.optionals.bg_disabled);
        log_field!(rl, self.optionals.bg_focused);
        log_field!(rl, self.optionals.border);
        log_field!(rl, self.optionals.border_disabled);
        log_field!(rl, self.optionals.border_focused);
        log_field!(rl, self.optionals.text);
        log_field!(rl, self.optionals.text_disabled);
        log_field!(rl, self.optionals.text_focused);
    }

    /// Updates `BORDER_COLOR_NORMAL` with `optionals.border`. Returns the wrapped color, other wise
    /// returns the default `BORDER_COLOR_NORMAL` color.
    fn update_border(&self, rl: &mut RaylibHandle) -> i32 {
        match self.optionals.border {
            Some(border) => {
                let border = border.color_to_int();
                rl.gui_set_style(
                    GuiControl::DEFAULT,
                    GuiControlProperty::BORDER_COLOR_NORMAL,
                    border,
                );
                border
            }
            None => rl.gui_get_style(GuiControl::DEFAULT, GuiControlProperty::BORDER_COLOR_NORMAL),
        }
    }

    /// Updates `BASE_COLOR_NORMAL` and `BACKGROUND_COLOR` with `bg`.
    fn update_bg(&self, rl: &mut RaylibHandle) {
        rl.gui_set_style(
            GuiControl::DEFAULT,
            GuiControlProperty::BASE_COLOR_NORMAL,
            self.bg.color_to_int(),
        );
        rl.gui_set_style(
            GuiControl::DEFAULT,
            GuiDefaultProperty::BACKGROUND_COLOR,
            self.bg.color_to_int(),
        );
    }

    /// Updates `BASE_COLOR_FOCUSED` with `option.bg_focused`. If `None`, sets it to `accent` with 1.0f
    /// alpha applied.
    fn update_bg_focused(&self, rl: &mut RaylibHandle) {
        match self.optionals.bg_focused {
            Some(bg_focused) => rl.gui_set_style(
                GuiControl::DEFAULT,
                GuiControlProperty::BASE_COLOR_FOCUSED,
                bg_focused.color_to_int(),
            ),
            None => rl.gui_set_style(
                GuiControl::DEFAULT,
                GuiControlProperty::BASE_COLOR_FOCUSED,
                self.accent.alpha(1.).color_to_int(),
            ),
        }
    }

    /// Updates `BASE_COLOR_DISABLED` with `optionals.bg_disabled`. If `None`, sets it to `border`
    /// if `dark == true` or `BORDER_COLOR_DISABLED` otherwise.
    fn update_bg_disabled(&self, rl: &mut RaylibHandle, border: i32) {
        match self.optionals.bg_disabled {
            Some(bg_disabled) => rl.gui_set_style(
                GuiControl::DEFAULT,
                GuiControlProperty::BASE_COLOR_DISABLED,
                bg_disabled.color_to_int(),
            ),
            None => {
                let border_disabled = rl.gui_get_style(
                    GuiControl::DEFAULT,
                    GuiControlProperty::BORDER_COLOR_DISABLED,
                );
                rl.gui_set_style(
                    GuiControl::DEFAULT,
                    GuiControlProperty::BASE_COLOR_DISABLED,
                    if self.dark { border } else { border_disabled },
                )
            }
        }
    }

    /// Updates `BORDER_COLOR_DISABLED` with `optionals.border_disabled`. If `None`, sets it to `BASE_COLOR_DISABLED`
    /// if `dark == false`. Otherwise, leaves it unchanged.
    fn update_border_disabled(&self, rl: &mut RaylibHandle) {
        match self.optionals.border_disabled {
            Some(border_disabled) => rl.gui_set_style(
                GuiControl::DEFAULT,
                GuiControlProperty::BORDER_COLOR_DISABLED,
                border_disabled.color_to_int(),
            ),
            None => {
                if !self.dark {
                    let bg_disabled = rl.gui_get_style(
                        GuiControl::DEFAULT,
                        GuiControlProperty::BASE_COLOR_DISABLED,
                    );
                    rl.gui_set_style(
                        GuiControl::DEFAULT,
                        GuiControlProperty::BORDER_COLOR_DISABLED,
                        bg_disabled,
                    )
                }
            }
        }
    }

    /// Updates `BORDER_COLOR_FOCUSED` with `optionals.border_focused`. If `None`, sets it to `border`
    fn update_border_focused(&self, rl: &mut RaylibHandle, border: i32) {
        match self.optionals.border_focused {
            Some(border_focused) => rl.gui_set_style(
                GuiControl::DEFAULT,
                GuiControlProperty::BORDER_COLOR_FOCUSED,
                border_focused.color_to_int(),
            ),
            None => rl.gui_set_style(
                GuiControl::DEFAULT,
                GuiControlProperty::BORDER_COLOR_FOCUSED,
                border,
            ),
        }
    }

    /// Updates `TEXT_COLOR_NORMAL` with `optionals.text`. If `None`, sets it to white if `dark == true`
    /// or black otherwise.
    fn update_text(&self, rl: &mut RaylibHandle) {
        match self.optionals.text {
            Some(text) => rl.gui_set_style(
                GuiControl::DEFAULT,
                GuiControlProperty::TEXT_COLOR_NORMAL,
                text.color_to_int(),
            ),
            None => rl.gui_set_style(
                GuiControl::DEFAULT,
                GuiControlProperty::TEXT_COLOR_NORMAL,
                if self.dark {
                    Color::WHITE.color_to_int()
                } else {
                    Color::BLACK.color_to_int()
                },
            ),
        }
    }

    /// Updates `TEXT_COLOR_DISABLED` with `optionals.text_disabled`. If `None`, sets it to dimgray
    /// if `dark == false`. Otherwise, leaves it default.
    fn update_text_disabled(&self, rl: &mut RaylibHandle) {
        match self.optionals.text_disabled {
            Some(text_disabled) => rl.gui_set_style(
                GuiControl::DEFAULT,
                GuiControlProperty::TEXT_COLOR_DISABLED,
                text_disabled.color_to_int(),
            ),
            None => {
                if !self.dark {
                    rl.gui_set_style(
                        GuiControl::DEFAULT,
                        GuiControlProperty::TEXT_COLOR_DISABLED,
                        Color::DIMGRAY.color_to_int(),
                    );
                }
            }
        }
    }

    /// Update `TEXT_COLOR_FOCUSED` with `optionals.text_focused`. If `None`, sets it to black if
    /// `dark == true` or white otherwise.
    fn update_text_focused(&self, rl: &mut RaylibHandle) {
        match self.optionals.text_focused {
            Some(text_focused) => rl.gui_set_style(
                GuiControl::DEFAULT,
                GuiControlProperty::TEXT_COLOR_FOCUSED,
                text_focused.color_to_int(),
            ),
            None => rl.gui_set_style(
                GuiControl::DEFAULT,
                GuiControlProperty::TEXT_COLOR_FOCUSED,
                if self.dark {
                    Color::BLACK.color_to_int()
                } else {
                    Color::WHITE.color_to_int()
                },
            ),
        }
    }

    /// Updates the color of the titlebar according to `dark`. This only does something on Windows.
    fn update_titlebar(&self, _rl: &mut RaylibHandle) {
        #[cfg(windows)]
        self.update_titlebar_win32(_rl);
    }

    fn update_style(&self, rl: &mut RaylibHandle) {
        let border = self.update_border(rl);

        self.update_bg(rl);
        self.update_bg_focused(rl);
        self.update_bg_disabled(rl, border);
        self.update_border_disabled(rl);
        self.update_border_focused(rl, border);
        self.update_text(rl);
        self.update_text_disabled(rl);
        self.update_text_focused(rl);
        self.update_titlebar(rl);
    }
}

impl Default for FoximgStyle {
    fn default() -> Self {
        Self {
            dark: true,
            accent: FoximgColor(Color::new(245, 213, 246, 127)),
            bg: FoximgColor(Color::new(34, 12, 35, 255)),
            optionals: FoximgStyleOptionals::default(),
        }
    }
}

impl FoximgConfig for FoximgStyle {
    const FILE: &str = "foximg_style.toml";
    const LOCAL: bool = false;

    fn update(&self, rl: &mut RaylibHandle) {
        self.log_style(rl);
        self.update_style(rl);
    }
}

impl Foximg {
    pub(crate) fn save_state(&mut self) {
        // self.state.fullscreen = self.fullscreen;
        if self.state.fullscreen {
            self.rl.toggle_borderless_windowed();
        }

        self.state.maximized = self.rl.is_window_maximized();
        self.rl.restore_window();

        self.state.w = self.rl.get_screen_width();
        self.state.h = self.rl.get_screen_height();
        self.state.xy = {
            let position = self.rl.get_window_position();
            Some((position.x as i32, position.y as i32))
        };

        if self.state.to_file(&self.rl) {
            self.rl.trace_log(
                TraceLogLevel::LOG_INFO,
                &format!("FOXIMG: Saved state to \"{}\"", FoximgState::FILE),
            );
        }
    }
}
